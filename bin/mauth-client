#!/usr/bin/env ruby

$LOAD_PATH.unshift File.expand_path('../lib', File.dirname(__FILE__))

require 'rubygems'
require 'faraday'
require 'faraday_middleware'
require 'logger'
require 'mauth/client'
require 'mauth/faraday'
require 'yaml'
require 'term/ansicolor'

# OPTION PARSER 

require 'optparse'

$options = {:authenticate_response => true, :verbose => true, :color => nil}
opt_parser = OptionParser.new do |opts|
  opts.banner = "Usage: mauth-client [options] <verb> <url> [body]"

  opts.on("-v", "--[no-]verbose", "Run verbosely - output is like curl -v (this is the default)") do |v|
    $options[:verbose] = v
  end
  opts.on("-q", "Run quietly - only outputs the response body (same as --no-verbose)") do |v|
    $options[:verbose] = !v
  end
  opts.on("--[no-]authenticate", "Authenticate the response received") do |v|
    $options[:authenticate_response] = v
  end
  opts.on("--[no-]color", "Color the output (defaults to color if the output device is a TTY)") do |v|
    $options[:color] = v
  end
  opts.on("-t", "--content-type CONTENT-TYPE", "Sets the Content-Type header of the request") do |v|
    $options[:content_type] = v
  end
end
opt_parser.parse!
abort(opt_parser.help) unless (2..3).include?(ARGV.size)

# FIND MAUTH CONFIG 

possible_mauth_config_files = [
  ENV['MAUTH_CONFIG_YAML'],
  '~/.mauth_config.yml',
  './config/mauth.yml',
  './mauth.yml',
].compact

environment = ENV['RACK_ENV'] || ENV['RAILS_ENV'] || 'development'

mauth_config = possible_mauth_config_files.map do |filename|
  filename = File.expand_path(filename)
  if filename && File.exists?(filename)
    mauth_config_all_envs = YAML.load(File.read(filename))
    if mauth_config_all_envs && mauth_config_all_envs.is_a?(Hash) && mauth_config_all_envs[environment]
      mauth_config_all_envs[environment]
    end
  end
end.detect{|c| c }

unless mauth_config
  message = "could not find mauth config. giving up. please place a mauth config in one of the standard places, or point the MAUTH_CONFIG_YAML environment variable at an existing one. standard places are:"
  message += possible_mauth_config_files.map{|f| "\n\t#{f}" }.join
  abort message
end

# INSTANTIATE MAUTH CLIENT 

logger = Logger.new(STDERR)
mauth_client = MAuth::Client.new(mauth_config.merge('logger' => logger))

# OUTPUTTERS FOR FARADAY THAT SHOULD MOVE TO A LIB SOMEWHERE 

# outputs the response body to the given output device (defaulting to STDOUT) 
class FaradayOutputter < Faraday::Middleware
  def initialize(app, outdev=STDOUT)
    @app=app
    @outdev = outdev
  end

  def call(request_env)
    @app.call(request_env).on_complete do |response_env|
      @outdev.puts(response_env[:body] || '')
    end
  end
end

# this is to approximate `curl -v`s output. but it's all faked, whereas curl gives you 
# the real text written and read for request and response. whatever, close enough. 
class FaradayCurlVOutputter < FaradayOutputter

  # defines a method with the given name, applying coloring defined by any additional arguments. 
  # if $options[:color] is set, respects that; otherwise, applies color if the output device is a tty. 
  def self.color(name, *color_args)
    define_method(name) do |arg|
      if $options[:color].nil? ? @outdev.tty? : $options[:color]
        color_args.inject(arg) do |result, color_arg|
          Term::ANSIColor.send(color_arg, result)
        end
      else
        arg
      end
    end
  end

  color :info, :intense_yellow
  color :info_body, :yellow
  color :protocol

  color :request, :intense_cyan
  color :request_verb, :bold
  color :request_header
  color :request_blankline, :intense_cyan, :bold

  color :response, :intense_green
  color :response_status, :bold, :green
  color :response_header
  color :response_blankline, :intense_green, :bold
  color :response_body

  def call(request_env)
    @outdev.puts "#{info('*')} #{info_body("connect to #{request_env[:url].host} on port #{request_env[:url].port}")}"
    @outdev.puts "#{info('*')} #{info_body("getting our SSL on")}" if request_env[:url].scheme=='https'
    @outdev.puts "#{request('>')} #{request_verb(request_env[:method].to_s.upcase)} #{request_env[:url].path} #{protocol('HTTP/1.1' || 'or something - TODO')}"
    request_env[:request_headers].each do |k, v|
      @outdev.puts "#{request('>')} #{request_header(k)}#{request(':')} #{v}"
    end
    @outdev.puts "#{request_blankline('>')} "
    (request_env[:body] || '').split("\n", -1).each do |line|
      @outdev.puts "#{request('>')} #{line}"
    end
    @app.call(request_env).on_complete do |response_env|
      @outdev.puts "#{response('<')} #{protocol('HTTP/1.1' || 'or something - TODO')} #{response_status(response_env[:status].to_s)}"
      request_env[:response_headers].each do |k, v|
        @outdev.puts "#{response('<')} #{response_header(k)}#{response(':')} #{v}"
      end
      @outdev.puts "#{response_blankline  ('<')} "
      (response_env[:body] || '').split("\n", -1).each do |line|
        @outdev.puts "#{response('<')} #{response_body(line)}"
      end
    end
  end
end

# CONFIGURE THE FARADAY CONNECTION 

connection = Faraday.new do |builder|
  builder.use MAuth::Faraday::MAuthClientUserAgent, "MAuth-Client CLI"
  builder.use MAuth::Faraday::RequestSigner, :mauth_client => mauth_client
  if $options[:authenticate_response]
    builder.use MAuth::Faraday::ResponseAuthenticator, :mauth_client => mauth_client
  end
  builder.use $options[:verbose] ? FaradayCurlVOutputter : FaradayOutputter
  builder.adapter Faraday.default_adapter
end

httpmethod, url, body = *ARGV

unless Faraday::Connection::METHODS.map{|m| m.to_s.downcase }.include?(httpmethod.downcase)
  abort "Unrecognized HTTP method given: #{httpmethod}\n\n" + opt_parser.help
end

headers = {}
if $options[:content_type]
  headers['Content-Type'] = $options[:content_type]
else
  if body
    # I'd rather not have a default content-type, but if none is set then the HTTP adapter sets this to 
    # application/x-www-form-urlencoded anyway. application/json is a better default for our purposes. 
    headers['Content-Type'] = 'application/json'
  end
end

# OH LOOK IT'S FINALLY ACTUALLY CONNECTING TO SOMETHING

response = connection.run_request(httpmethod.downcase.to_sym, url, body, headers)
